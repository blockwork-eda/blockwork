# Copyright 2023, Blockwork, github.com/intuity/blockwork
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import logging
from dataclasses import dataclass, field
from pathlib import Path
from typing import Iterable, List, Optional, Union

from .entity import Entity
from .file import FileType
from .transform import Transform, TransformImpossible


@dataclass
class Edge:
    file     : Path
    filetype : FileType
    start    : Optional["Node"] = None
    end      : Optional["Node"] = None

    def __hash__(self) -> int:
        return id(self)

    def to_dot(self) -> Iterable[str]:
        yield f"{self.start.fullname} -> {self.end.fullname} [label=\"{self.file.name}\"];"
        yield from self.end.to_dot()


@dataclass
class Node:
    transform : Optional[Transform] = None
    name      : Optional[str]       = None
    inputs    : List[Edge]          = field(default_factory=list)
    outputs   : List[Edge]          = field(default_factory=list)

    def __hash__(self) -> int:
        return id(self)

    @property
    def fullname(self) -> str:
        return self.name or self.transform.name

    def to_dot(self) -> Iterable[str]:
        for output in self.outputs:
            yield from output.to_dot()


@dataclass
class Graph:
    origin : Node
    target : Node
    nodes  : List[Node] = field(default_factory=list)
    edges  : List[Edge] = field(default_factory=list)

    def to_dot(self) -> str:
        result  = "digraph blockwork {\n"
        result += "  node [shape=box];\n"
        result += "".join([f"  {x}\n" for x in self.origin.to_dot()])
        result += "}\n"
        return result

    def add(self, *objs : List[Union[Node, Edge]]) -> None:
        for obj in objs:
            if isinstance(obj, Node):
                self.nodes.append(obj)
            else:
                self.edges.append(obj)

    def pipeline(self) -> Iterable[List[Node]]:
        """
        Split the graph into pipeline-able stages, where each step only contains
        transforms that depends on files that come from the origin or are
        generated by a previous step.

        :returns:   An iterable set of steps where each step is a list of nodes
                    that can be evaluated at this point.
        """
        # Start with edges from the origin
        edges = set(self.origin.outputs)
        # Track the nodes that have been scheduled
        scheduled = {self.origin}
        # Search for nodes that can be scheduled
        while unscheduled := set(self.nodes).difference(scheduled):
            step = []
            # Accumulate steps first without mutating edges/scheduled list
            for node in unscheduled:
                if not set(node.inputs).difference(edges):
                    step.append(node)
            # Collect the new edges and scheduled step
            # NOTE: This is performed separately to ensure all selected steps
            #       can be scheduled in parallel without interdependencies
            for node in step:
                for edge in node.outputs:
                    edges.add(edge)
                scheduled.add(node)
            yield step


def orchestrate(entity : Entity, transform : Transform) -> Graph:
    """
    Evaluate a transformation against a particular entity, building a graph of
    any required intermediate transformations to support the operation.

    :param entity:      The base entity to evaluate
    :param transform:   The transformation to perform
    """
    # NOTE: For intermediate steps in the chain, there is currently no distinction
    #       between transforms that take one or more-than-one input, and how those
    #       map to outputs.
    # Prepare input file categories
    cat_inputs = { x: [] for x in transform.inputs }
    # Run through all of the available files
    for file in entity.get_host_files():
        ftype = FileType("".join(file.suffixes))
        for req_ftype in transform.inputs:
            if ftype is req_ftype:
                cat_inputs[req_ftype].append((ftype, file, []))
            else:
                try:
                    chain = Transform.identify_chain(ftype, req_ftype)
                    cat_inputs[req_ftype].append((ftype, file, chain))
                except TransformImpossible:
                    pass
    # Warn for empty categories
    # TODO: Should there be a marker on an input category to say whether is is
    #       required or optional - that could then be enforced at this stage?
    for ftype, _files in filter(lambda x: len(x[1]) == 0, cat_inputs.items()):
        logging.warning(f"No files identified for input type '{ftype.extension}' "
                        f"of transform '{transform.name}' for entity '{entity.name}'")
    # Assemble a graph
    origin = Node(name="origin")
    target = Node(transform=transform)
    graph  = Graph(origin, target)
    graph.add(origin, target)
    for _ftype, inputs in cat_inputs.items():
        for src_type, src_file, chain in inputs:
            base_name = src_file.name.rstrip(src_type.extension)
            # Create the initial edge
            edge = Edge(src_file, src_type, origin, None)
            origin.outputs.append(edge)
            graph.add(edge)
            # Evaluate the chain
            for _in_type, out_type, tran in chain:
                node     = Node(transform=tran, inputs=[edge])
                edge.end = node
                edge     = Edge(Transform.ROOT / (base_name + f"{out_type.extension}"),
                                out_type,
                                node)
                node.outputs.append(edge)
                graph.add(node, edge)
            # Attach the edge onto the target
            target.inputs.append(edge)
            edge.end = target
    # Return the build graph
    return graph
